require! <[mongodb]>

main = (driver) ->
  {db,ds} = driver{db,ds}
  col = {}

  OID = mongodb.ObjectID
  get-collection = (name, cb) -> 
    if !col[name] => retun db.collection name, (e, ret) -> cb(col[name] = ret)
    else cb(col[name])

  get-collection \palette
  get-collection \palset
  get-collection \fav/palette

  return store = do
    read: (prefix, key) -> new bluebird (res, rej) -> (root) <- get-collection prefix
      try
        root.findOne {_id: OID key}, (e,b) -> res b
      catch => res null
    write: (prefix, key, data) -> new bluebird (res, rej) -> (root) <- get-collection prefix
      if key => 
        (e,r,b) <- root.update {_id: OID key},  {$set: data}, {upsert: true, w:1}
        return res b
      else 
        if data._id => delete data._id
        (e,b) <- root.insert data, {w:1}
        b = b.0
        b.key = b._id
        (e,r,c) <- root.update {_id: OID b._id}, {$set: {key: b._id}}, {w: 1}
        return res b

    delete: (prefix, key) -> new bluebird (res, rej) -> (root) <- get-collection prefix
      root.remove {_id: OID key} -> res!

    list: (prefix, field, values) -> new bluebird (res, rej) -> (root) <- get-collection prefix
      query = {}
      if typeof(values) == typeof([]) and values.length => 
        if field == \key => values = values.map(->OID it)
        query[field] = { $in: values }
      else query[field] = values
      cursor = root.find(query).toArray (e,b) -> res b

/*
  return store = do
    list: do
      by-user: (user, prefix, cb) -> 
        cursor = ds[prefix].find {owner: user}
        cursor.toArray (e,b) -> cb b.map(-> 
          if !it.key => it.key = it._id
          it
        ).filter(-> !it.deleted)
      by-key: (keys, prefix, cb) -> 
        cursor = ds[prefix].find {_id: {$in: keys.map(->OID it)}}
        cursor.toArray (e,b) -> cb b.map(->
          if !it.key => it.key = it._id
          it
        ).filter(->!it.deleted)
    exists: (prefix, id, cb) -> ds[prefix].findOne {_id: OID id}, (e,b) -> cb b
    write: (prefix, id, json, cb) -> 
      if id => 
        (e,r,b) <- ds[prefix].update {_id: OID id},  {$set: json}, {upsert: true, w:1}
        return cb b
      else 
        if json._id => delete json._id
        (e,b) <- ds[prefix].insert json, {w:1}
        b = b.0
        (e,r,c) <- ds[prefix].update {_id: OID b._id}, {$set: {key: b._id}}, {w: 1}
        b.key = b._id
        return cb b

    read: (prefix, id, cb) -> 
      #TODO fix: id should always generated by system
      try
        ds[prefix].findOne {_id: OID id}, (e,b) -> cb b
      catch => return cb {}
    delete: (prefix, id, cb) -> ds[prefix].remove {_id: OID id}, cb
    fav: (prefix, id, user, cb) ->
      (data) <- store.read prefix, id, _
      if !data => return cb!
      (favhash={}) <- store.read "fav/#prefix", user.username, _
      isOn = if favhash[id] => true else false
      if isOn => delete favhash[id]
      else favhash[id] = 1
      <- store.write "fav/#prefix", user.username, favhash, _
      data.fav = (data.fav or 0) + (if isOn => -1 else 1)
      store.write prefix, id, data, -> cb !isOn
    key: (prefix) -> null
    palette: do
      lint: (payload) ->
        if !payload or !payload.name or !payload.[]colors.length => return false
        if payload.[]colors.filter(-> !it.hex or it.hex.length >10 or (it.semantic or "").length > 20).length => return false
        if payload.name.length > 20 or (payload.category or "").length > 20 => return false
        return true
      clean: (payload, req) ->
        cleandata = {colors: []} <<< payload{name, category}
        for item in payload.colors => cleandata.colors.push {} <<< item{hex, semantic}
        return cleandata
      create: (payload, req) ->
        cleandata = @clean payload, req
        cleandata.owner = req.user.username
        cleandata.key = store.key \palette
        return cleandata
    palettes: do
      lint: (payload) ->
        if !payload or !payload.name => return false
        if payload.[]palettes.filter(-> typeof(it) != typeof("") or it.length >= 20 ).length => return false
        return true
      clean: (payload, req) ->
        cleandata = {palettes: []} <<< payload{name}
        (palettes) <- store.list.by-key payload.[]palettes, \palette, _
        cleandata.palettes = palettes.filter(->!it.deleted).map(-> it.key)
        return cleandata
      expand: (payload) ->
        if !payload.palettes.length or payload.palettes.0.colors => return
        (palettes) <- store.list.by-key payload.[]palettes, \palette, _
        payload.palettes = palettes.filter(->!it.deleted)
      create: (payload, req) ->
        cleandata = @clean payload, req
        cleandata.owner = req.user.username
        cleandata.key = store.key \palettes
        return cleandata
*/
module.exports = main
